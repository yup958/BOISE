# sample 1e5 clones from truncated, Pareto distribution, as an approximation of repertoire. scale to 1e11 cells
clones = VGAM::rpareto(1e5, scale = 2, shape = 1+rho)
clones = clones / sum(clones) * 1e11
# find median of truncated power-law
target = C / 2
med = 2
cumsum = 0
### 10/25 updates: P(N) follows truncated power-law dist. compare median for sample cell vs. sample clone
upper = 1e11
rho = 0.1
# sample 1e5 clones from truncated, Pareto distribution, as an approximation of repertoire. scale to 1e11 cells
clones = VGAM::rpareto(1e5, scale = 2, shape = 1+rho)
clones = clones / sum(clones) * 1e11
clones = sort(clones)
cumsum = 0
for (clone in clones) {
cumsum = cumsum + clone
if(cumsum > 5e10){
break
}
}
print(clone)
# sample 1e5 clones from truncated, Pareto distribution, as an approximation of repertoire. scale to 1e11 cells
clones = VGAM::rpareto(1e6, scale = 2, shape = 1+rho)
clones = clones / sum(clones) * 1e11
clones = sort(clones)
cumsum = 0
for (clone in clones) {
cumsum = cumsum + clone
if(cumsum > 5e10){
break
}
}
print(clone)
setwd('~/RAwork/BOISE/BOISE_followup/')
### Define a function to find m0 that minimize prior and posterior difference
harmonic_sum <- function(start, end){
res = 0
for(k in start:end){
res = res + 1/k
}
return(res)
}
m0_Find <- function(x0, lower, upper){
a = rep(mean(x0), ncol(x0))
b = 1 - a
n = nrow(x0)
min_diff = 1000
best_m0 = 1
for(m0 in seq(lower, upper, by = 3)){
prior_m0_expect = m0 * harmonic_sum(start = m0, end = m0+n-1)
cl_sample = dpmm_beta(x0, a, b, m0, burn_in = 500, sample_size=100, thinning = 5)
diff = abs(mean(cl_sample$KK) - prior_m0_expect)
if(diff < min_diff){
min_diff = diff
best_m0 = m0
}
}
return(best_m0)
}
M_generate <- function(P){
M = apply(P, 2, function(p){
return(rbinom(length(p), 1, p))
})
M_sum = apply(M, 1, sum)
while (length(which(M_sum == 0)) > 0) {
M = apply(P, 2, function(p){
return(rbinom(length(p), 1, p))
})
M_sum = apply(M, 1, sum)
}
return(M)
}
alpha = 0.06
beta = 0.94
set.seed(2)
# generating matrices with clustering in rows and columns
col_cl = BOISE::Initial_beta(x0 = matrix(0, 200, 200), m0 = 10)
P = matrix(0, nrow=100, ncol = 200)
prev_col = 0
for(k in 1:col_cl$K){
ncols = col_cl$N[k]
m0 = sample(3:15, size = 1, replace = T)
row_cl = BOISE::Initial_beta(x0 = matrix(0, 100, 100), m0 = m0)
probs = rbeta(row_cl$K, alpha, beta)
prev_row = 0
for(r in 1:row_cl$K){
nrows = row_cl$N[r]
P[(prev_row+1) : (prev_row+nrows), (prev_col+1):(prev_col+ncols)] = probs[r]
prev_row = prev_row + nrows
}
prev_col = prev_col + ncols
}
library(plot.matrix)
plot(P)
plot(P, main = "Synthetic Probability Matrix with Blocks", xlab = 'Compounds', ylab = 'Targets')
